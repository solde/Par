<style>
    @import url('https://fonts.googleapis.com/css?family=VT323');
    h1{
        text-align: center;
        font-size: 50px;
        font-family: 'VT323', monospace;
    }
    h2{
        font-weight: bold;
    }
    h3{
        font-weight: bold;
    }
    img {
        height: auto;
        width: 100%;
    }
    note {
        font-weight: lighter;
        background-color: rgba(100, 100, 100, 0.3);
        font-style: italic;
    }
    p{
        text-align: justify;
    }
    img{
        width: 100%;
        height: auto;
    }
    .center{
        width: 50%;
        height: auto;
        margin-left: auto;
        margin-right: auto;
        display: block;
    }
    .half{
        width: 50%;
        height: auto;
        margin-left: auto;
        margin-right: auto;
    }
    .mini{
        width: 30%;
        height: auto;
        margin-left: auto;
        margin-right: auto;
        display: block;
    }
</style>

# LAB 4
## <center>Branch and bound with OpenMP: N-queens puzzle</center>

<br></br>
#### <center>2018-2019 Q1<center>
<br></br><br></br><br></br><br></br><br></br><br></br><br></br>
<br></br><br></br><br></br><br></br></br><br></br>
### <center>Par2013</center>
### <center>Daniel Palomo Cabrera i David Soldevila Puigbi</center>

<div class="page">

## Introduction

First of all, we are going to understand the nqueens algorithm. It consist of a recursive algorithm that tries to put N chess queens into a N x N chess table in order that every queen doesnâ€™t attack any other queen (no column, row or diagonal is shared).

<div class="page">

## Understanding the potential parallelism in Nqueens

Executing the sequential version of the program with 12 queens in a table of 12 x 12 the program gives us the following output:

```
  board size:              12
  recursion cutoff level:  8

one solution:  0  2  4  7  9 11  5 10  1  6  8  3

number of solutions: 14200
```

The code of nqueens fuctions with tareadors calls:
```
void nqueens(int n, int j, char *a, int d) {
     int i;

     if (n == j) {
#ifdef _TAREADOR_
          tareador_start_task("Solution");
#endif
          /* put good solution in heap. */
	if( sol == NULL ) {
			sol = malloc(n * sizeof(char));
			memcpy(sol, a, n * sizeof(char));
	}
	sol_count += 1;

#ifdef _TAREADOR_
          tareador_end_task("Solution");
#endif
     } else {
          /* try each possible position for queen <j> */
          for ( i=0 ; i < n ; i++ ) {
                          
#ifdef _TAREADOR_
		  sprintf(stringMessage,"Trying [%d,%d]",j,i);
		  tareador_start_task(stringMessage);
#endif
			b[j] = (char) i;
			if (ok(j + 1, b)) {
					nqueens(n, j + 1, b,d+1);
			}
#ifdef _TAREADOR_
			tareador_end_task(stringMessage);
#endif
          }
     }
}
```
[nqueens-tar.c](codes/nqueens-tar.c)

Lets discuss about the parallelization of the algorithm using Tareador. First take a look at the dependence graph for the execution of the algorithm with n equals 4.

<img src="tareador/graph.png">
<note>Dependence grpah generated by Tareador</note>

Even thought Tareador shows that block with id 1 (bottom left) at the second row it can be executed at the same time of the blocks in the first row. Note this at the simulation with different number of cores. 

<img src="tareador/1c.png">
<note>Simulation of execution of nqeens using 1 core</note>
<img src="tareador/2c.png">
<note>Simulation of execution of nqeens using 2 core</note>
<img src="tareador/4c.png">
<note>Simulation of execution of nqeens using 4 core</note>
<img src="tareador/8c.png">
<note>Simulation of execution of nqeens using 8 core</note>
<img src="tareador/16c.png">
<note>Simulation of execution of nqeens using 16 core</note>

With 32 cores the time is exactly the same as the 16 cores simulation. 

<div class="page">

## Shared-memory parallelization

At last we will parallelice the nqueen algorithm using OpenMP.

In order to reach a good level of parallelization for each task the program creates a copy of the chess board. That strategy eliminates the dependence of reading and writing the chess board.

Last, we introduced a critical zone at the basic case, only one thread should be the one who edits the number of solutions. And the resulting code is:

```
void nqueens(int n, int j, char *a, int d) {
	int i;
	if (n == j) {
	#ifdef _TAREADOR_
		tareador_start_task("Solution");
	#endif
		/* put good solution in heap. */
	#pragma omp critical
	{
		if( sol == NULL ) {
			sol = malloc(n * sizeof(char));
			memcpy(sol, a, n * sizeof(char));
		}
		sol_count += 1;
	}
	#ifdef _TAREADOR_
	tareador_end_task("Solution");
	#endif
	} else {
		/* try each possible position for queen <j> */
		for ( i=0 ; i < n ; i++ ) {
			#ifdef _TAREADOR_
				sprintf(stringMessage,"Trying [%d,%d]",j,i);
				tareador_start_task(stringMessage);
			#endif
			char* b = alloca(sizeof(a));
			memcpy(b, a, sizeof(a));
			#pragma omp task final (d<CUTOFF) mergeable
			{
				b[j] = (char) i;
				if (ok(j + 1, b)) {
					nqueens(n, j + 1, b,d+1);
				} 
			}   
			#ifdef _TAREADOR_
				tareador_end_task(stringMessage);
			#endif
		}
		#pragma omp taskwait 
	}
}
```
[nqueens-omp.c](codes/nqueens-omp.c)


With that changes we got the following elapsed time and speed up polts.

<img src="plots/plots.png">
<note>Speed Up and elapsed time plots for n=13</note>

Note that scalability is not as perfect as the previous sessions. Now we are going to discuss the performance with paraver captures (if it works).

<img src="paraver/term.png"> 

However, we can't execute paraver, tareador or any other program with GUI, in addition, we cannot create any paraver trace because theres no available disk space. But we only have the code of the previous laboratory and the necessary for this one.

Therefore we can't fully complete this deliverable as asked